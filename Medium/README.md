#### 快速冪

x^13 -> x = 3, y = 13

13 -> 1101 (二進位制)

| y   | y % 2 | 操作              | ret     | mul        |
|-----|--------|---------------------|----------|-------------|
| 13  | 1      | ret ×= 3            | 3        | 3 → 9       |
| 6   | 0      | 無操作              | 3        | 9 → 81      |
| 3   | 1      | ret ×= 81           | 243      | 81 → 6561   |
| 1   | 1      | ret ×= 6561         | 1594323  | 6561 → ...  |
| 0   | -      | 結束                | 1594323  |             |


網址:https://zh.wikipedia.org/zh-tw/%E4%BA%8C%E8%BF%9B%E5%88%B6

#### Dijkstra algorithms
Use BFS + priority_queue;

因為單純的nested loop會有相對的更新方向(左下到右上)，這個動作會使得問題的值在不是最佳化的時間下更新，導致結果不符合，所以使用greedy algorithms(priority queue)來搜尋最短路徑。

又可以稱作Best-First Search

#### 3408 improvement note

---

##### **1. 關鍵效能瓶頸：`edit` 與 `rmv` 函式**

| 舊有的程式碼 | 優化後的程式碼 | 說明 |
| :--- | :--- | :--- |
| `edit` 和 `rmv` 使用 `for` 迴圈來遍歷 `std::set`。 | `edit` 和 `rmv` 使用 `std::set` 的 `erase` 和 `insert` 方法，並透過 `unordered_map` 來快速定位。 | 這是最主要的效能差異。`for` 迴圈的**時間複雜度是 O(n)**，當任務數量 `n` 很大時，會導致程式超時。而 `std::set` 的 `erase` 和 `insert` 方法的**時間複雜度是 O(log n)**，效率更高。|

---

##### **2. 資料結構設計**

| 舊的程式碼 | 優化後的程式碼 | 說明 |
| :--- | :--- | :--- |
| 使用 `unordered_map<int, int> task_user`，只儲存 `taskId` 到 `userId` 的映射。 | 使用 `unordered_map<int, pair<int, int>> task_user_info`，儲存 `taskId` 到 `{priority, userId}` 的映射。 | 舊有的 `unordered_map` 無法儲存優先級，因此在 `edit` 和 `rmv` 函式中，舊有版本必須透過遍歷 `set` 來找到對應的優先級，這造成了效能瓶頸。修改後的版本則將所有任務資訊都儲存在 `map` 中，方便快速查找。|

---

##### **3. `execTop` 函式的處理邏輯**

| 舊有程式碼 | 優化後的程式碼 | 說明 |
| :--- | :--- | :--- |
| 在 `execTop` 中，舊版本使用 `task_user[pri_task_set.begin()->second]` 來取得 `userId`。 | 在 `execTop` 中，新版本先取得 `taskId`，再用 `taskId` 去 `task_user_info` 查詢 `userId`。 | 雖然原本的寫法也能運作，但修改後的版本在邏輯上更清晰。因為 `pri_task_set` 儲存的是 `{priority, taskId}`，先從 `set` 取得 `taskId`，再用 `taskId` 去 `map` 找詳細資訊，符合一般資料庫查詢的思維模式。|

---

##### **總結**

程式碼主要的問題在於**沒有充分利用資料結構的優勢**。`std::set` 雖然是有序的，但要透過線性搜尋來尋找特定元素，其效能與 `std::vector` 相去不遠。

修改版則結合了 `std::set` 的**自動排序**功能和 `std::unordered_map` 的**快速查找**功能，將兩者的優點結合起來，從而大幅提升了整體效能。

本身set資料結構是使用balanced binary search，所以其符合BST性質

1. 以左邊節點 ( left node ) 作為根的子樹 ( sub-tree ) 的所有值都小於根節點 ( root )
2.  以右邊節點 ( right node ) 作為根的子樹 ( sub-tree ) 的所有值都大於根節點 ( root )
3.  任意節點 ( node ) 的左、右子樹也分別符合 BST 的定義
4.  不存在任何鍵值 ( key/value ) 相等的節點。

#### 3508 note

只有vector, array, deque這一種資料結構可以使用upper_bound lower_bound找上下限的概念去找其中間元素有幾個。(Random Access Iterator)

其他迭代器因為記憶體不連續，並不支持使用記憶體互減的方式獲得中間有多少元素值。

#### 165 note

問題: 同樣的錯誤code狀況下，為何短的case不會抱錯，較長的case會抱錯呢?

---

##### 1. 為什麼簡單的案例會輸出方塊符號？

當存取 `version1[4]` 時，已經讀取了字串範圍之外的記憶體。但為什麼沒有崩潰？

這是因為 C++ 標準函式庫中的 `std::string` 通常會在內部為字串內容多分配一些額外的空間，這段空間被稱為**緩衝區 (buffer)**。當你越界讀取時，可能只是讀到了這個額外空間中的**垃圾數據**。

* **小字串**：對於 `"1.0"` 這種很小的字串，它們通常會被存儲在一個相對獨立、且後面接著一塊未使用的記憶體區塊中。
* **輸出到 `cout`**：將 `version1[4]` 傳給 `cout` 時，`cout` 嘗試將這個未知的位元組印出來。如果這個位元組恰好是一個不可印的字元（non-printable character），它就會顯示為一個**方塊符號**或其他奇怪的亂碼。
* **ASan 沒有立即報錯**：ASan 是一種特殊的記憶體偵錯工具。它會在記憶體前後加上保護區域，也就是**紅色區域（red zones）**。當程式碼讀取或寫入這些紅色區域時，ASan 會立即報錯。但在簡單的案例中，可能只是讀到了緩衝區內的**白色區域（white zone）**，即未使用的有效記憶體，ASan 不會對此發出警告。這就是為什麼沒有崩潰的原因。

##### 2. 為什麼較長的案例會直接崩潰？

長字串的情況則完全不同。

* **大字串的分配**：當 `std::string` 需要分配數百個甚至數千個位元組來存儲一個長字串時，它通常會直接向堆積（heap）記憶體管理器請求一個精確大小的記憶體區塊。
* **越界存取**：當越界讀取長字串的最後一個位元組之後的記憶體時，很可能已經觸及了**另一個已經被分配的記憶體區塊**，或者 ASan 為字串所設定的**紅色區域**。
* **ASan 的作用**：ASan 的職責就是捕捉這種**跨越記憶體區塊邊界**的錯誤。當它檢測到試圖讀取或寫入紅色區域時，它就會立即終止程式，並給一個詳細的錯誤報告。

---

##### **總結**

這兩個案例的行為差異，並非程式碼邏輯有不同，而是因為**記憶體配置與 ASan 的偵測機制**在兩種情況下產生了不同的結果。

* 在小字串案例中，越界讀取的是**無害的、未使用的記憶體**，ASan 的保護區域沒有被觸及，程式只是輸出了亂碼。
* 在長字串案例中，越界讀取的是**ASan 的保護區域**，這是一個明確的越界信號，所以 ASan 立即報錯，保護程式免於進一步的未定義行為。

這也再次印證了一個黃金法則：**只要程式碼中存在未定義行為，即使在某些情況下沒有崩潰，也不能認為它是正確的。** 任何依賴未定義行為的程式碼都是不穩定的，隨時可能在不同的編譯器、作業系統或輸入下崩潰。

#### 407 note

**重新定義了「小於」的判斷標準，以便讓 Max-Heap 將我們想要的最小值誤認為是最大值。**

**核心原則：Priority Queue 只使用 `operator<`**

##### 1. 預設規則 (Max-Heap)

`std::priority_queue` 預設是 Max-Heap，它決定優先級的邏輯是：

| 程式碼問句 | 邏輯意義 | 優先級決定 |
| :--- | :--- | :--- |
| **`A < B`** | **$A$ 是否「小於」 $B$？** | 如果 `true`，則 $B$ 優先級高（$B$ 會被排在 $A$ 前面）。 |

##### 2. 你的程式碼 (Min-Heap 模擬)

程式碼 (`return height >= other.height;`) 定義了新的 `<` 運算符：

| 程式碼問句 | 新的邏輯意義 | 優先級決定 |
| :--- | :--- | :--- |
| **`A < B`** | **$A$.height 是否 $\ge$ $B$.height？** |
| | 如果 `true`，Max-Heap 認為 $A$ **小於** $B$（$B$ 優先級高）。 |
| | 如果 `false`，Max-Heap 認為 $A$ **不小於** $B$（$A$ 優先級高）。 |

---

##### 最終效果：Min-Heap 達成

假設有兩個 `Cell`：
* $A$: height = 5
* $B$: height = 10

1.  **希望：** $A$ (高度 5) 優先級高，應被放在堆頂。
2.  **程式執行：** 計算 $A < B$ (即 $5 \ge 10$)，結果為 **`false`**。
3.  **Max-Heap 解讀：** 因為 $A < B$ 是 `false`，所以 Max-Heap 認為 $A$ **更大**（優先級更高）。

因此，**高度越小**，`operator<` 回傳 **`false`** 的機率越高，這反而使 Max-Heap 認為該元素**具有最高優先級**，成功將最小元素推到堆頂，實現 **Min-Heap**。

